单一职责
你的组件是否符合只实现一个职责，并且只有一个改变状态的理由？
如fetch请求和渲染逻辑，应该分离。因为fetch请求时会造成组件重新渲染，渲染时的样式或数据格式变化，也会引起组件重新渲染。
单一职责可以保证组件是最细的粒度，且有利于复用。但太细的粒度有时又会造成组件的碎片化。
因此单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件，我们仅仅作为独立组件的内部组件即可。
通用性
组件开发要服务于业务，为了更好的复用，又要从业务中抽离。

作者：^_^在掘金43335
链接：https://juejin.cn/post/6844904032700481550
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
封装
良好的组件封装应该隐藏内部细节和实现意义，并通过props来控制行为和输出。

减少访问全局变量：因为它们打破了封装，创造了不可预测的行为，并且使测试变得困难。可以将全局变量作为组件的props，而不是直接引用。
纯组件和非纯组件
非纯组件有显示的副作用，我们要尽量隔离非纯代码。

将全局变量作为props传递给组件，而非将其注入到组件的作用域中。

将网络请求和组件渲染分离，只将数据传递给组件，保证组件职责的单一性，也能将非纯代码从组件中隔离。
复制代码
可测试
测试不仅仅是自动检测错误，更是检测组件的逻辑。

如果一个组件测试不易于测试，很大可能是你的组件设计存在问题。
复制代码
富有意义
开发人员大部分时间都在阅读和理解代码，而不是实际编写代码。
有意义的函数、变量命名，可以让代码具有良好的可读性。

作者：^_^在掘金43335
链接：https://juejin.cn/post/6844904032700481550
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。