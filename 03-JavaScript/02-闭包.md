## 闭包的定义

- JS 中存在两种变量作用域，分别是局部变量和全局变量，这两种变量存在区别就是函数内部的可以访问全局变量，但是函数外部无法访问函数内的局部变量。
- 闭包就是有权访问另一函数作用域中局部变量的函数

## 闭包的危害

闭包会导致原有作用域链不释放，造成内存泄露。解决内存泄漏应该及时释放。

## 闭包的应用

核心：创建私有变量、延长变量的生命周期

1. 闭包实现模块化
2. 实现变量私有化
3. 实现缓存
4. 函数柯立化
5. 模拟块级作用域

## 哪些操作会造成内存泄漏？

https://developer.51cto.com/article/683431.html

1. 意外的全局变量
2. 被忘记的定时器或者回调函数
3. 脱离 DOM 的引用
4. 闭包

## 垃圾回收机制

阮一峰内存泄露教程：http://www.ruanyifeng.com/blog/2017/04/memory-leak.html

### 什么是 js 的回收机制

1. 按照固定的时间间隔(或代码中预定的收集时间)，周期性地执行地找到不再继续使用的变量，释放其内存。
2. 全部变量的声明周期会一直持续，直到页面卸载; 而局部变量声明在函数中，它的声明周期从执行函数开始，直到函数执行结束。函数执行结束，这些局部变量也不再被使用，它们所占用的空间也就被释放;
3. 垃圾回收的两种实现方式：标记清除、引用计数

**标记清除**
主要思想是给当前不使用的值加上标记，然后再回收他的内存;

- JavaScript 最常用的垃圾收集方式
- 当变量进入环境时，这个变量标记为“进入环境”
- 而当变量离开环境时，则将其标记为“离开环境”
- 可以使用一个“进入环境”的变量列表及一个“离开环境”的变量列表来跟踪变量的变化
- 也可以翻转某个特殊的位来记录一个变量何时进入环境及离开环境

**引用计数**
引用计数的含义是跟踪记录每个值被引用的次数

- 当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是 1；
- 如果同一个值又被赋给另一个变量，则该值的引用次数加 1；
- 如果包含对该值引用的变量又取得了另外一个值，则该值的引用次数减 1
- 当该值的引用次数变为 0 时，则可以回收其占用的内存空间
- 当垃圾回收器下一次运行时，就会释放那些引用次数为 0 的值所占用的内存
- 无法回收循环引用的变量

## 函数柯里化

Currying 为实现多参函数提供了一个递归降解的实现思路
把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回了一个可以处理余下参数的新函数。

```JavaScript
function curriedAdd (x) {

  return function(y) {

    return x + y

  }
}
```

## 闭包面试题

```JavaScript
/*
变量的作用域是在函数定义声明的时候就是确定的，而非在函数运行时
* return返回的对象的fun属性对应一个新建的函数对象，
* 这个函数对象将形成一个闭包作用域，
* 使其能够访问外层函数的变量n及外层函数fun,为了不将fun函数和fun属性搞混，
* 我们将上述代码修改如下:
* */
function _fun_(n, o) {
    console.log(o);
    return {
        fun: function (m) {
            return _fun_(m, n);
        }
    }
}

var a = _fun_(0);//undefined
a.fun(1);//0
a.fun(2);//0
a.fun(3);//0

var b = _fun_(0).fun(1).fun(2).fun(3);
//undefined,0,1,2

var c = _fun_(0).fun(1);//undefined,0,
c.fun(2);//1
c.fun(3); //1
```
